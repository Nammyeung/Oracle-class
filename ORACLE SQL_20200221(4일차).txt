-- 20200224일(4일차)

DROP TABLE EMP01;
CREATE TABLE EMP01
AS
SELECT * FROM EMP;

DROP TABLE EMP02;
CREATE TABLE EMP02
AS
SELECT * FROM EMP
WHERE JOB = 'MANAGER';
SELECT * FROM EMP02;

UPDATE EMP02
SET JOB = 'TEST';
SELECT * FROM EMP02;

INSERT INTO EMP02
VALUES(8000, 'SYJ', 'TOP', 7566, '2009/01/12', 1200, 10, 20);

MERGE INTO EMP01
USING EMP02
ON(EMP01.EMPNO = EMP02.EMPNO)
WHEN MATCHED THEN
UPDATE SET
EMP01.ENAME = EMP02.ENAME,
EMP01.JOB = EMP02.JOB,
EMP01.MGR = EMP02.MGR,
EMP01.HIREDATE = EMP02.HIREDATE,
EMP01.SAL = EMP02.SAL,
EMP01.COMM = EMP02.COMM,
EMP01.DEPTNO = EMP02.DEPTNO
WHEN NOT MATCHED THEN
INSERT VALUES(EMP02.EMPNO, EMP02.ENAME, EMP02.JOB,
EMP02.MGR, EMP02.HIREDATE, EMP02.SAL,
EMP02.COMM, EMP02.DEPTNO);

SELECT * FROM EMP01;
SELECT * FROM EMP01;

SELECT * FROM EMP02;

SELECT * FROM DEPT;
DROP TABLE DEPT02;
CREATE TABLE DEPT02
AS
SELECT * FROM DEPT;
SELECT * FROM DEPT02;

-- DML : INSERT, DELETE, UPDATE
DELETE FROM DEPT02
WHERE DEPTNO = 40;

-- DDL : CREATE, DROP, ALTER, TRUNCATE
-- DDL 명령어를 수행하게되면 자동으로 COMMIT 된다.
CREATE TABLE DEPT03
AS
SELECT * FROM DEPT;

SELECT * FROM DEPT03;

ROLLBACK; 
-- 롤백이 안됨. DML은 COMMIT은 해야지만 롤백이 안되는데 수행이 안됨 => DDL에는 자동으로 COMMIT 기능 있음

DROP TABLE DEPT03;
CREATE TABLE DEPT03
AS
SELECT * FROM DEPT;

SELECT * FROM DEPT03;

DELETE FROM DEPT03
WHERE DEPTNO = 20; -- DML이므로 롤백하면

ROLLBACK; -- DEPTNO = 20 데이터 살아남

TRUNCATE TABLE DEPTPPP; 
-- 해당 명령어가 수행이 오류가 났음에도 이전의 DELETE문(DML)이 ROLLBACK으로 복구가 안됨.

DROP TABLE DEPT01;
CREATE TABLE DEPT01
AS
SELECT * FROM DEPT;

SELECT * FROM DEPT01;

DELETE FROM DEPT01 WHERE DEPTNO = 40;

COMMIT;

DELETE FROM DEPT01
WHERE DEPTNO = 30;

SAVEPOINT C1;

DELETE FROM DEPT01
WHERE DEPTNO = 20;

SAVEPOINT C2;

DELETE FROM DEPT01
WHERE DEPTNO = 10;
SELECT * FROM DEPT01;

ROLLBACK TO C2;
ROLLBACK TO C1;
ROLLBACK;
SELECT * FROM DEPT01;

INSERT INTO DEPT
VALUES(10, 'TEST', 'SEOUL'); -- 중복하지 못하도록 설정

SELECT * FROM DEPT;

DESC DEPT;
DESC USER_CONSTRAINTS; -- 오라클이 자동으로 넣어놓은 데이터 구조

SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'DEPT';

DROP TABLE EMP01;
CREATE TABLE EMP01 (
    EMPNO NUMBER(4),
    ENAME VARCHAR2(10),
    JOB   VARCHAR2(9),
    DEPTNO NUMBER(2)
);

SELECT * FROM EMP01;
DESC EMP01;

INSERT INTO EMP01 VALUES(NULL, NULL, 'SALESMAN', 30);


DROP TABLE EMP02;
CREATE TABLE EMP02 (
    EMPNO   NUMBER(4) NOT NULL,
    ENAME   VARCHAR2(10) NOT NULL,
    JOB     VARCHAR(9),
    DEPTNO  NUMBER(2)
);

INSERT INTO EMP02 VALUES(NULL, NULL, 'SALESMAN', 30); -- 에러
INSERT INTO EMP02 VALUES(10,'LEE','SALESMAN',30);

SELECT * FROM EMP02;

SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'EMP02';

DROP TABLE EMP03;
CREATE TABLE EMP03 (
    EMPNO   NUMBER(4) UNIQUE,
    ENAME   VARCHAR2(10) NOT NULL,
    JOB     VARCHAR2(9),
    DEPTNO  NUMBER(2)
);

INSERT INTO EMP03
VALUES(7499, 'ALLEN', 'SALESMAN', 30);

SELECT * FROM EMP03;

INSERT INTO EMP03
VALUES(7499, 'JONES', 'MANAGER', 20); 
-- unique constraint (SCOTT.SYS_C007033) violated

INSERT INTO EMP03
VALUES(NULL, 'LEE', 'MANAGER', 30); 
-- NULL은 모르는 값이기 때문에 비교할 수 없어 들어감.

DROP TABLE EMP04;
CREATE TABLE EMP04 (
    EMPNO   NUMBER(4) CONSTRAINT EMP04_EMPNO_UK UNIQUE, --- 컬럼 레벨로 제약 조건
    --  CONSTRAINT EMP04_EMPNO_UK => 제약조건 지정
    ENAME VARCHAR2(10)
);

SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'EMP04';

DROP TABLE EMP05;
CREATE TABLE EMP05 (
    EMPNO NUMBER(4) CONSTRAINT EMP05_EMPNO_PK PRIMARY KEY,
    ENAME VARCHAR2(10) CONSTRAINT EMP05_ENAME_NN_NOT NULL,
    JOB VARCHAR2(9),
    DEPTNO NUMBER(2)
);
INSERT INTO EMP05 VALUES(7499, 'ALLIEN', 'SALESMAN', 30);
SELECT * FROM EMP05;

INSERT INTO EMP05 VALUES(7499, 'JONES', 'MANAGER', 20);
INSERT INTO EMP05 VALUES(7498, NULL, 'MANAGER', 20);
-- unique constraint (SCOTT.EMP05_EMPNO_PK) violated
INSERT INTO EMP05 ALUES(NULL, 'LEE', 'STAFF', 20);
-- missing SELECT keyword 00928. 00000 -  "missing SELECT keyword"
-- Primary 키는 Not Null 제약조건도 포함.
-- PRIMARY 키 = Unique + Not Null

DESC EMP;
DESC DEPT;

SELECT TABLE_NAME, CONSTRAINT_TYPE, CONSTRAINT_NAME, R_CONSTRAINT_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME IN ('DEPT', 'EMP');

-- 외래키(FK, FORIEGN KEY) 제약 조건 설정하기
DROP TABLE EMP06;
CREATE TABLE EMP06(
    EMPNO NUMBER(4) CONSTRAINT EMP06_EMPNO_PK PRIMARY KEY,
    ENAME VARCHAR2(10) CONSTRAINT EMP06_ENAME_NN NOT NULL,
    JOB VARCHAR(9),
    DEPTNO NUMBER(2) CONSTRAINT EMP06_DEPTNO_FK REFERENCES DEPT(DEPTNO)
);

INSERT INTO EMP06 VALUES(7499, 'ALLEN', 'SALESMAN', 30);

SELECT * FROM EMP06;
SELECT * FROM DEPT;

INSERT INTO EMP06 VALUES(7498, 'KIM', 'SALESMAN', 40); 
-- 안들어감, integrity(무결성)에 위배(참조값에 해당하지 않는 값이 들어갔기 때문)

SELECT TABLE_NAME, CONSTRAINT_TYPE, CONSTRAINT_NAME, R_CONSTRAINT_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME IN ('EMP06'); -- 제약조건을 확인하는 명령문

-- CHECK 특정한 데이터를 넣도록 제약, DEFAULT : 값을 넣지 않으면 자동적으로 들어가도록 규정

DROP TABLE EMP07;
CREATE TABLE EMP07(
    EMPNO NUMBER(4) CONSTRAINT EMP07_EMPNO_PK PRIMARY KEY,
    ENAME VARCHAR2(10) CONSTRAINT EMP07_ENAME_NN NOT NULL,
    SAL NUMBER(7,2) CONSTRAINT EMP07_SAL_CK CHECK(SAL BETWEEN 500 AND 5000),
    GENDER VARCHAR(1) CONSTRAINT EMP07_GENDER_CK CHECK(GENDER IN('M','F'))
);

INSERT INTO EMP07 VALUES(7499,'ALLEN',500,'M');
INSERT INTO EMP07 VALUES(7498,'LEE',7000,'F'); 
-- check constraint (SCOTT.EMP07_SAL_CK) violated
INSERT INTO EMP07 VALUES(7498,'LEE',4000,'A'); 
-- check constraint (SCOTT.EMP07_GENDER_CK) violated

-- DEFAULT 제약 조건
DROP TABLE DEPT01;
CREATE TABLE DEPT01(
    DEPTNO NUMBER(2) PRIMARY KEY,
    DNAME VARCHAR2(14),
    LOC VARCHAR2(13) DEFAULT 'SEOUL'
);

INSERT INTO DEPT01 (DEPTNO, DNAME) VALUES (10, 'ACCOUNTING');

SELECT * FROM DEPT01; 
-- 상위 명령문에 LOC값을 설정하지 않아도 LOC 안에 서울이 들어가 있음.

DROP TABLE EMP01;
CREATE TABLE EMP01 (
    EMPNO NUMBER(4) PRIMARY KEY, -- 컬럼 레벨 방식
    ENAME VARCHAR2(10) NOT NULL -- PRIMARY KEY, table can have only one primary key
    JOB VARCHAR2(9) UNIQUE,
    DEPTNO NUMBER(4) REFERENCES DEPT(DEPTNO)
);

-- 테이블 레벨 방식
DROP TABLE EMP02;
CREATE TABLE EMP02 (
    EMPNO NUMBER(4),
    ENAME VARCHAR2(10),
    JOB VARCHAR2(9),
    DEPTNO NUMBER(4),
    PRIMARY KEY(EMPNO, ENAME), 
    -- 두 개의 데이터를 조합해서 Unique하게 구별하겠다. => 복합키, KISS(KEEP IT SIMPLE STUPID!)
    UNIQUE(JOB),
    FOREIGN KEY(DEPTNO) REFERENCES DEPT(DEPTNO)
);

-- 제약 조건의 비활성화

-- CASCADE 옵션
SELECT * FROM DEPT01;
DROP TABLE DEPT01;

CREATE TABLE DEPT01
AS
SELECT * FROM DEPT;

ALTER TABLE DEPT01
ADD CONSTRAINT DEPT01_DEPTNO_PK PRIMARY KEY (DEPTNO); 
-- 테이블 레벨 방식

DESC DEPT01;

DROP TABLE EMP01;

CREATE TABLE EMP01
AS
SELECT * FROM EMP WHERE 1 = 0;

SELECT * FROM EMP01;

ALTER TABLE EMP01
ADD CONSTRAINT EMP01_DEPTNO_FK FOREIGN KEY(DEPTNO) REFERENCES DEPT01(DEPTNO);

SELECT * FROM DEPT01;
DESC EMP01;

SELECT * FROM EMP01;
SELECT * FROM DEPT01;

INSERT INTO EMP01 (DEPTNO) VALUES (10);

INSERT INTO EMP01 (DEPTNO) VALUES (50); 
-- integrity constraint (SCOTT.EMP01_DEPTNO_FK) violated - parent key not found

-- [과제] 과제-13-01.TXT 
-- 1. 다음과 같은 구조의 테이블을 생성해 보자. (단, 테이블 레벨방식 사용) 

DROP TABLE ORDERS;
CREATE TABLE ORDERS (
    ORDER_ID NUMBER(12,0),
    ORDER_DATE DATE,
    ORDER_MODE VARCHAR2(8) CONSTRAINT ORDERS_ORDERMODE_CK CHECK(ORDER_MODE IN('direct','online')),
    CUSTOMER_ID NUMBER(6,0),
    ORDER_STATUS NUMBER(2,0),
    ORDER_TOTAL NUMBER(8,2) DEFAULT 0,
    SALES_REP_ID NUMBER(6,0),
    PROMOTION_ID NUMBER(6,0),
    PRIMARY KEY(ORDER_ID)
    );

SELECT * FROM ORDERS;

CREATE TABLE ORDER_ITEMS (
    ORDER_ID NUMBER(12,0),
    LINE_ITEM_ID NUMBER(3,0) DEFAULT 0,
    PRODUCT_ID NUMBER(3,0),
    UNIT_PRICE NUMBER(8,2) DEFAULT 0,
    QUANTITY NUMBER(8,0),
    PRIMARY KEY(ORDER_ID, LINE_ITEM_ID)
);

---------------- 정답
DROP TABLE ORDERS;
CREATE TABLE ORDERS (  
    ORDER_ID     NUMBER(12,0),
    ORDER_DATE   DATE,
    ORDER_MODE   VARCHAR2(8),
    CUSTOMER_ID NUMBER(6,0),           
    ORDER_STATUS NUMBER(2,0),           
    ORDER_TOTAL NUMBER(8,2) DEFAULT 0,      
    SALES_REP_ID NUMBER(6,0),
    PROMOTION_ID NUMBER(6,0), 
    PRIMARY KEY (ORDER_ID),
    CHECK(ORDER_MODE IN ('direct', 'online'))
    -- 제약사항 : 기본키는 ORDER_ID                ORDER_MODE에는 'direct', 'online'만 입력가능              ORDER_TOTAL의 디폴트 값은 0 
 );
ALTER TABLE ORDERS
ADD CONSTRAINT ORDERS_ORDERID_PK PRIMARY KEY (ORDER_ID)
ADD CONSTRAINT ORDERS_ORDERMODE_CK CHECK(ORDER_MODE IN ('direct', 'online'));

SELECT EMPNO, ENAME, JOB, MGR, HIREDATE, DEPTNO FROM EMP; -- 컬럼을 만든 다음 뷰 생성

DROP TABLE DEPT_COPY;

CREATE TABLE DEPT_COPY
AS
SELECT * FROM DEPT;

DROP TABLE EMP_COPY;

CREATE TABLE EMP_COPY
AS
SELECT * FROM EMP;

SELECT * FROM DEPT_COPY;
SELECT * FROM EMP_COPY;

DESC EMP_VIEW30;
DROP VIEW EMP_VIEW;

CREATE OR REPLACE VIEW EMP_VIEW(사원번호, 사원명, 부서번호) 
-- OR REPLACE => 기존에 있는 것을 새롭게 변경하라
AS
SELECT EMPNO, ENAME, DEPTNO
FROM EMP_COPY;

CREATE OR REPLACE VIEW EMP_VIEW_DEPT
AS
SELECT E.EMPNO, E.ENAME, E.SAL, E.DEPTNO, D.DNAME, D.LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
ORDER BY E.EMPNO DESC;

SELECT * FROM EMP_VIEW_DEPT; -- JOIN을 안해도 보여주는

DROP TABLE DEPT_COPY; 
CREATE TABLE DEPT_COPY AS SELECT * FROM DEPT; 
 
DROP TABLE EMP_COPY; 
CREATE TABLE EMP_COPY AS SELECT * FROM EMP; 
 
SELECT * FROM DEPT_COPY; 
SELECT * FROM EMP_COPY; 

-- 뷰를 생성할 권한이 불충분한 경우 
CREATE OR REPLACE VIEW EMP_VIEW30 AS SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP_COPY WHERE DEPTNO=30;
-- SQL Error: ORA-01031: insufficient privileges 

conn system/manager

CONN system
GRANT CREATE VIEW TO SCOTT;
CONN SCOTT/TIGER

SELECT * FROM EMP_VIEW30;

DESC EMP_VIEW30;

DESC EMPLOYEES

CREATE OR REPLACE VIEW EMPLOYEES_VIEW
AS
SELECT EMPNO, ENAME, DEPTNO
FROM EMPLOYEES
WHERE DEPTNO = 30;

CREATE OR REPLACE FORCE VIEW NOTABLE_VIEW
AS
SELECT EMPNO, ENAME, DEPTNO
FROM EMPLOYEES
WHERE DEPTNO=30;

SELECT VIEW_NAME, TEXT FROM USER_VIEWS;

-- NOFORCE는 뷰 생성의 디폴트값으로 FORCE의 반대 기능을 가진 옵션이다.
CREATE OR REPLACE NOFORCE VIEW EXISTTABLE_VIEW
AS
SELECT EMPNO, ENAME, DEPTNO
FROM EMPLOYEES
WHERE DEPTNO=30;

SELECT VIEW_NAME, TEXT
FROM USER_VIEWS;

CREATE OR REPLACE VIEW EXISTTABLE_VIEW
AS
SELECT EMPNO, ENAME, DEPTNO
FROM EMPLOYEES
WHERE DEPTNO = 30;

CREATE OR REPLACE VIEW VIEW_CHK30
AS
SELECT EMPNO, ENAME, SAL, COMM, DEPTNO
FROM EMP_COPY
-- WHERE DEPTNO=30 WITH CHECK OPTION;
WHERE DEPTNO=30 WITH READ ONLY;

UPDATE VIEW_CHK30 SET DEPTNO=20
WHERE SAL >= 1200; -- 
-- *** 조건 제시에 사용된 값 ***만 변경을 못하게 막는 것 => WITH CHECK OPTION
UPDATE VIEW_CHK30 SET ENAME = 'TEST'; -- 바뀜?? // WITH READ ONLY에서는 바꿀 수 없음.
SELECT * FROM VIEW_CHK30;
SELECT * FROM EMP_COPY; -- VIEW를 했는데 오리지널을 업데이트


DROP TABLE EMP_COPY;
CREATE TABLE EMP_COPY
AS
SELECT * FROM EMP;
SELECT * FROM EMP_COPY;

--  뷰 활용하여 Top-N 구하기 *******
SELECT * FROM EMP;

SELECT ROWNUM, EMPNO, ENAME, HIREDATE
FROM EMP
ORDER BY ENAME ASC; 
-- 데이터를 넣을 때 ROWNUM대로 11번째에 들어감, 이를 이용해서 Top-N을 구할 수 있다.

SELECT RNUM, ENAME, SAL FROM 
    (SELECT ROWNUM RNUM, ENAME, SAL FROM 
    (SELECT * FROM EMP ORDER BY SAL DESC)) 
    WHERE RNUM BETWEEN 6 AND 10; -- 페이징 처리
-- MY SQL은 다른 방법으로 처리함.

SELECT ROWNUM RNUM, ENAME, SAL FROM 
    (SELECT * FROM EMP ORDER BY SAL DESC);
     
    
SELECT * FROM EMP ORDER BY SAL DESC;

/* SELECT * FROM EMP 
ORDER BY SAL DESC LIMIT 1 AND 5; */
-- ****** MySQL 방법

SELECT * FROM
    (SELECT ROWNUM RNUM, ENAME, SAL FROM
        (SELECT * FROM EMP ORDER BY SAL DESC))
WHERE RNUM BETWEEN 1 AND 15;
-- ********* ORACLE 방법

-- 기본키 UNIQUE, NULL값

SELECT * FROM EMP;

SELECT * FROM EMP
ORDER BY EMPNO DESC;

CREATE SEQUENCE DEPT_DEPTNO_SEQ
INCREMENT BY 10
START WITH 10; -- 1부터 시작해서 10씩 증가한다.

SELECT DEPT_DEPTNO_SEQ.NEXTVAL FROM DUAL; 
-- 중복되지 않고 계속 변화, ROWVALUE를 PRIMARY로
SELECT DEPT_DEPTNO_SEQ.CURRVAL FROM DUAL;

DESC USER_SEQUENCES;
SELECT SEQUENCE_NAME, MIN_VALUE, MAX_VALUE, INCREMENT_BY, CYCLE_FLAG
FROM USER_SEQUENCES;