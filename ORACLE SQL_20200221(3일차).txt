SELECT * FROM DEPT02;

SELECT * FROM DEPT;

SELECT * FROM EMP;

SELECT DNAME, LOC FROM DEPT;

INSERT INTO DEPT VALUES(50, '총무부', '서울'); /* DEPT 테이블 안에 ()안의 VALUES를 넣는다 */
UPDATE DEPT SET LOC='부산' WHERE DNAME='총무부'; /* DEPT 테이블의 총무부를 찾아서 해당 LOC 변수에 해당하는 데이터를 부산으로 바꿔라 ( WHERE = IF ) */
DELETE FROM DEPT WHERE DEPTNO=50;  

SELECT * FROM DEPT01;

CREATE TABLE DEPT01 (    
DEPTNO NUMBER(4),    
DNAME VARCHAR2(10),    
LOC VARCHAR2(9) ); /* TABLE DEPT01을 생성하고 3개의 변수 이름 자료형(자료 크기) 를 형성한다 */ 

DESC DEPT02; -- description.

ALTER TABLE DEPT01 MODIFY(DNAME VARCHAR2(30)); /* DEPT01 테이블을 변경하는데 변수 DNAME의 자료형 VARCHAR2의 크기를 10에서 30으로 변경하겠다. */ 

RENAME DEPT01 TO DEPT02; /* 테이블 이름은 DEPT01에서 DEPT02로 변경하겠다*/

INSERT INTO DEPT02 VALUES(10, '개발부', '서울'); /* VALUES에 해당하는 데이터 (큰따옴표로 묶지 말고 작은따옴표로 묶어서)를 DEPT02테이블로 넣는다. */

TRUNCATE TABLE DEPT02; /* 테이블은 그대로 유지한 채 테이블의 값을 모두 제거한다.(DROP + COMMIT) */

DROP TABLE DEPT02; /* TRUNCATE 명령어와는 다르게 DEPT02 테이블을 완전하게 제거 */

DROP TABLE DEPT02 CASCADE CONSTRAINTS;  -- CASCADE CONSTRAINTS 옵션은 종속된 제약조건을 삭제한다. 

SELECT * FROM TAB;

DESC EMP;
SELECT * FROM EMP;

SELECT * FROM EMP;

SELECT ENAME, AVG(SAL) "AVERAGe" FROM EMP GROUP BY ENAME;

SELECT ENAME, SAL, JOB, COMM, SAL*12, SAL*12+COMM FROM EMP; /* x + NULL 값을 모르는 값으로 처리 => NULL이 0이 아닌 조사되어지지 못한 값으로 여기기 때문*/

SELECT ENAME, SAL, JOB, COMM, SAL*12, SAL*12+NVL(COMM, 0) FROM EMP

SELECT ENAME, SAL*12+NVL(COMM, 0) AS ANNSAL FROM EMP;

-- AS 키워드는 생략이 가능하다. 
SELECT ENAME, SAL*12+NVL(COMM, 0) ANNSAL FROM EMP; 

SELECT ENAME, SAL*12+NVL(COMM, 0) "A N N S A L" FROM EMP; 

SELECT ENAME, SAL*12+NVL(COMM, 0) "연봉" FROM EMP;

SELECT ENAME || ' IS A ' || JOB "sentence" FROM EMP; /* 중간에 문자를 연결하여 하나의 변수를 생성 가능 */

SELECT DEPTNO FROM EMP;

SELECT DISTINCT DEPTNO 
FROM EMP;

DESC EMP;

SELECT DISTINCT DEPTNO FROM EMP;

SELECT * FROM EMP;

SELECT * FROM EMP WHERE SAL >= 3000; -- EMP 테이블의 모든 변수의 값을 SAL 변수의 값이 3000이 넘는 범위 안에서 표출

SELECT * FROM EMP WHERE SAL <> 3000;

SELECT EMPNO, ENAME, SAL FROM EMP WHERE ENAME = 'FORD';

SELECT EMPNO, ENAME, SAL FROM EMP WHERE ENAME = 'ford'; -- 테이블 내에 저장된 데이터 값은 대소문자를 구분한다. => 출력 x 

SELECT EMPNO, ENAME, SAL FROM EMP WHERE ENAME = 'FORD';

SELECT * FROM EMP;

SELECT * FROM EMP WHERE HIREDATE <= '1982/01/01';

/* 
논리합(OR, ||)
   T OR T = T
   T OR F = T
   F OR T = T
   F OR F = F
   
논리곱 (AND, &&)
   T AND T = T
   T AND F = F
   F AND T = F
   F AND F = F
   
   
*/
select * from emp where deptno = 10 and job = 'MANAGER' ;
SELECT * FROM emp WHERE DEPTNO = 10 AND JOB = 'MANAGER' ; -- 명령문은 대소문자를 안가림 // 데이터는 대소문자 가림

SELECT * FROM EMP WHERE NOT DEPTNO = 10;

SELECT * FROM EMP WHERE SAL >= 2000 AND SAL <= 3000;

SELECT * FROM EMP WHERE SAL BETWEEN 2000 AND 3000;

SELECT * FROM EMP WHERE SAL NOT BETWEEN 2000 AND 3000;

SELECT * FROM EMP WHERE HIREDATE BETWEEN '1987/01/01' AND '1987/12/31';

SELECT * FROM EMP WHERE COMM=300 OR COMM=500 OR COMM=1400;

SELECT * FROM EMP WHERE COMM IN(300, 500, 1400);

SELECT * FROM EMP WHERE COMM<>300 AND COMM<>500 AND COMM<>1400; 

SELECT * FROM EMP WHERE COMM NOT IN(300, 500, 1400); 

SELECT * FROM EMP WHERE ENAME LIKE 'F%';

SELECT * FROM EMP WHERE ENAME LIKE '%A%'; -- A 문자를 포함한 데이터 선택

SELECT * FROM EMP WHERE ENAME LIKE '%N'; -- 가장 뒷 자리의 문자가 N인 데이터 선택

SELECT * FROM EMP WHERE ENAME LIKE '_A%'; -- 한자리, 두번째 자리가 반드시 A인 데이터

SELECT * FROM EMP WHERE ENAME LIKE '__A%'; -- 세번째 자리가 반드시 A인 데이터

SELECT * FROM EMP WHERE ENAME NOT LIKE '%A%'; 

SELECT * FROM EMP WHERE COMM=NULL;  -- NULL 값을 = 연산자로 판단할 수 없다. 

SELECT * FROM EMP WHERE COMM IS NULL;  -- EMP 테이블에서 COMM 컬럼이 NULL 사원을 출력한다.

SELECT * FROM EMP WHERE COMM IS NOT NULL; -- NULL은 모르는 값이기 때문에 EQUAL(=)로 동등비교를 할 수 없다?

SELECT * FROM EMP ORDER BY SAL ASC; -- 생략해도 기본값이 오름차순

SELECT * FROM EMP ORDER BY SAL;

SELECT * FROM EMP ORDER BY ENAME;  -- 문자 데이터의 경우 아스키 코드 값으로 저장되므로 
--아스키 코드 값을 기준으로 정렬된다. 

SELECT * FROM EMP ORDER BY SAL DESC;  
SELECT * FROM EMP ORDER BY HIREDATE DESC;  
SELECT * FROM EMP ORDER BY SAL DESC, ENAME ASC; 

--1
SELECT * FROM EMP ORDER BY HIREDATE DESC, EMPNO ASC;
--2
SELECT DEPTNO AS "사원", ENAME "사원번호" FROM EMP WHERE ENAME LIKE 'K%';
--3
SELECT DEPTNO AS "사원", ENAME "사원번호" FROM EMP WHERE ENAME LIKE '%K%';
--4
SELECT DEPTNO AS "사원", ENAME "사원번호" FROM EMP WHERE ENAME LIKE '%K_';

/*
PL/SQL(피엘에스큐엘)은 상용 관계형 데이터베이스 시스템인 오라클 DBMS에서 
SQL 언어를 확장하기 위해 사용하는 컴퓨터 프로그래밍 언어 중 하나이다.
*/
-- '--' 입력어가 statement 역할을 한다
-- 데이터베이스에서 NULL은 "unknown"값이다. => 알려지지 않은 내용이기 때문에

-- CROSS JOIN
SELECT * FROM EMP; -- 테이블 갯수 14개
SELECT * FROM DEPT; -- 테이블 갯수 4개

SELECT * FROM EMP, DEPT; -- 14 * 4 56

-- EQUI JOIN
SELECT * FROM EMP, DEPT WHERE emp.deptno = dept.deptno; -- 기본키끼리 연결
SELECT EMP.ENAME, DEPT.DNAME FROM EMP, DEPT WHERE emp.deptno = dept.deptno AND EMP.ENAME = 'SMITH';
SELECT EMP.ENAME, DEPT.DNAME, DEPT.DEPTNO FROM EMP, DEPT WHERE emp.deptno = dept.deptno;

-- NON-EQUI JOIN
SELECT * FROM SALGRADE;
SELECT * FROM EMP;
SELECT MIN(SAL), MAX(SAL) FROM EMP;
SELECT * FROM SALGRADE;

SELECT ENAME, SAL, GRADE
FROM EMP, SALGRADE
WHERE SAL BETWEEN LOSAL AND HISAL; -- EMP 테이블의 SALARY가 SALGRADE의 LOSAL과 HISAL 사이에 있는 값에 해당하는 데이터를 추출

SELECT EMP.ENAME, EMP.SAL, SALGRADE.GRADE FROM EMP, SALGRADE WHERE SAL BETWEEN LOSAL AND HISAL;

SELECT E.ENAME, E.SAL, S.GRADE FROM EMP E, SALGRADE S WHERE E.SAL >= S.LOSAL AND E.SAL <= S.HISAL;

-- SELF JOIN
SELECT * FROM EMP;

SELECT E.ENAME, M.ENAME AS MANAGER FROM EMP E, EMP M WHERE e.mgr = M.EMPNO;

-- 1. ex3_6란 테이블을 만들고, 사원테이블(employees)에서 관리자사번이 124번이고 
-- 급여가 2000에서 3000 사이에 있는 사원의 사번, 사원명, 급여, 관리자사번을 입력하는
-- INSERT문을 작성해보자.

CREATE TABLE ex3_6 (
    employee_id NUMBER(6),
    emp_name VARCHAR2(80),
    salary NUMBER(8,2),
    manager_id NUMBER(6) );
    
    INSERT INTO ex3_6
    SELECT employee_id, emp_name, salary, manager_id
    FROM employees a where a.manager_id = 124 and a.salary between 2000 and 3000;
    
    select e.ename , e.sal, s.grade
    from emp e, salgrade s
    where e.sal >= s.losal and e.sal <=s.hisal;
    
    select job from emp where ename = 'SMITH';
    select * from emp where job=(select job from emp where ename='SMITH'); 
    
-- SQL> CONN SCOTT/TIGER 로 접속하여 SQL문을 작성하세요.  
-- 1.매니저가 KING인 사원들의 이름과 직급을 출력하세요.  
-- <정답>

-- 20200221(3일차)

SELECT * FROM EMP;

SELECT * FROM EMP E, EMP M WHERE E.MGR = M.EMPNO AND M.ENAME = 'KING';

-- 2. SMITH와 동일한 직급(JOB컬럼)을 가진 사원의 이름과 직급을 출력하는 SQL문을 작성 하세요?  
-- <정답>

SELECT * FROM EMP WHERE ENAME = 'SCOTT';

SELECT * FROM DEPT D;

SELECT * FROM EMP E, DEPT D; -- EMP + EMPT(DNAME, LOC)


SELECT * FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO AND E.ENAME = 'SCOTT';

SELECT * FROM EMP E, EMP C WHERE E.DEPTNO = C.DEPTNO AND E.ENAME = 'SCOTT';

SELECT * FROM EMP E, EMP C WHERE E.DEPTNO = C.DEPTNO AND E.ENAME = 'SCOTT' AND C.ENAME <> 'SCOTT';

-- SQL> CONN SCOTT/TIGER 로 접속하여 SQL문을 작성하세요.  
-- 1. 조인을 사용하여 뉴욕에서 근무하는 사원의 이름과 급여을 출력하세요.  
-- <정답>
SELECT * FROM DEPT D, EMP E WHERE D.LOC = 'NEW YORK';

SELECT * FROM DEPT D, EMP E WHERE E.DEPTNO = D.DEPTNO AND D.LOC = 'NEW YORK';

-- 2. 조인을 사용하여 ACCOUNTING 부서 소속 사원의 이름과 입사일을 출력하세요.  
-- <정답>

SELECT * FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO AND D.DNAME = 'ACCOUNTING' ORDER BY LOC ASC;

-- 3. 직급이 MANAGER인 사원의 이름, 부서명을 출력하세요.
-- <정답>
SELECT * FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO AND JOB = 'MANAGER';

-- Outer Join

SELECT * FROM EMP E, EMP M WHERE E.MGR = M.EMPNO(+); 

-- ANSI Join(미국표준협회, American National Standard Institute)

-- ANSI CROSS JOIN
SELECT * FROM EMP CROSS JOIN DEPT; -- 다른 데이터베이스도 작동
-- Oracle Cross Join
SELECT * FROM EMP, DEPT;

-- ANSI CROSS JOIN = ORCALE CROSS JOIN

-- ANSI INNER JOIN
SELECT ENAME, DNAME FROM EMP INNER JOIN DEPT -- , 대신에 INNTER JOIN하고 붙이려는 테이블
ON EMP, DEPTNO = DEPT.DEPTNO

-- ORACLE EQUI JOIN
SELECT ENAME, DNAME FROM EMP, DEPT WHERE EMP.DEPTNO = DEPT.DEPTNO;

-- USING을 이용함
SELECT ENAME, DNAME FROM EMP INNER JOIN DEPT USING(DEPTNO); -- INNER JOIN을 USING할 변수를 ()에 입력

-- NATURAL JOIN
SELECT ENAME, DNAME FROM EMP NATURAL JOIN DEPT; -- NATURAL JOIN = ORACLE QUI JOIN

-- [과제] 과제-07-02.TXT SQL> CONN SCOTT/TIGER 로 접속하여 SQL문을 작성하세요.  
-- 1. 직급이 MANAGER인 사원의 이름, 부서명을 출력하는 SQL문을 작성 하세요? 
-- (ORACLE EQUI JOIN, ANSI INNER JOIN, ANSI NATURAL JOIN을 사용하여 처리)  

SELECT * FROM EMP INNER JOIN DEPT USING(DEPTNO) WHERE JOB = 'MANAGER';
SELECT ENAME, DNAME FROM EMP INNER JOIN DEPT USING(DEPTNO) WHERE JOB = 'MANAGER';
SELECT ENAME, DNAME FROM EMP, DEPT WHERE EMP.DEPTNO = DEPT.DEPTNO AND JOB = 'MANAGER';
select ENAME, DNAME FROM EMP NATURAL JOIN DEPT WHERE JOB = 'MANAGER';
--정답
-- ORACLE EQUI JOIN
SELECT E.ENAME, D.DNAME FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO AND E.JOB = 'MANAGER';

-- ANSI INNER JOIN
SELECT E.ENAME, D.DNAME FROM EMP E INNER JOIN DEPT D ON E.DEPTNO = D.DEPTNO AND E.JOB = 'MANAGER';

-- USING
SELECT E.ENAME, D.DNAME FROM EMP E INNER JOIN DEPT D USING(DEPTNO) WHERE E.JOB = 'MANAGER';

-- ARSI NATURAL JOIN
SELECT E.ENAME, D.DNAME FROM EMP E NATURAL JOIN DEPT D WHERE E.JOB = 'MANAGER';

SELECT ENAME, SAL FROM EMP;

SELECT ENAME, SAL FROM EMP WHERE SAL > (SELECT AVG(SAL) FROM EMP);

SELECT DISTINCT DEPTNO FROM EMP WHERE SAL >= 3000; -- 두개의 연산자가 나와서 QUI 연산자를 사용할 수 없음.
SELECT ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO IN (SELECT DISTINCT DEPTNO FROM EMP WHERE SAL >= 3000);
-- IN 연산자는 메인 쿼리의 비교 조건에서 서브 쿼리의 출력 결과와 하나라도 일치하면 메인 쿼리의 WHERE절이 

SELECT * FROM EMP WHERE DEPTNO = 30;
SELECT ENAME, SAL FROM EMP WHERE SAL > ALL(SELECT SAL FROM EMP WHERE DEPTNO = 30); -- 최대값

-- 내부의 SAL 조건을 모두 만족하는 SAL 값을 가진 데이터를 SELECT

SELECT SAL FROM EMP WHERE DEPTNO = 30;
SELECT ENAME, SAL FROM EMP WHERE SAL > ANY ( SELECT SAL FROM EMP WHERE DEPTNO = 30); -- 최소값
SELECT SAL FROM EMP WHERE DEPTNO > 30;
SELECT ENAME, SAL FROM EMP WHERE SAL > ANY ( SELECT SAL FROM EMP WHERE DEPTNO > 30);
SELECT SAL FROM EMP WHERE DEPTNO < 30;
SELECT ENAME, SAL FROM EMP WHERE SAL > ANY ( SELECT SAL FROM EMP WHERE DEPTNO < 30);

-- EXISTS 연산자 : 서브쿼리에 결과 값이 하나 이상 존재하면 조건식이 모두 TRUE,
-- 존재하지 않으면 모두 FALSE가 되는 연산자이다.
SELECT DNAME FROM DEPT WHERE DEPTNO = 10;
SELECT * FROM EMP WHERE EXISTS (SELECT DNAME FROM DEPT WHERE DEPTNO = 10);

-- EXISTS 연산자를 사용하여 대한민국에 거주하는 고객에게 판매한 도서의 총 판매액을 구하기
SELECT * FROM CUSTOMER CS WHERE ADDRESS LIKE '%대한민국%' AND CS.CUSTID=OD.CUSTID;
SELECT SUM(SALEPRICE) "TOTAL" FROM ORDERS OD WHERE EXISTS 
( SELECT * FROM CUSTOMER CS WHERE ADDRESS LIKE '%대한민국%' AND CS.CUSTID=OD.CUSTID);
SELECT * FROM DEPT WHERE DEPTNO < 50;
SELECT * FROM EMP WHERE EXISTS (SELECT DNAME FROM DEPT WHERE DEPTNO < 10);

SELECT * FROM JOB_HISTORY;
SELECT * FROM EMPLOYEES;
SELECT E.EMPLOYEE_ID, E.EMP_NAME, H.JOB_ID, H.START_DATE, H.END_DATE, H.DEPARTMENT_ID  FROM EMPLOYEES E, JOB_HISTORY H WHERE E.EMPLOYEE_ID = H.EMPLOYEE_ID;

-- 정답
-- SQL> CONN ORA_USER/HONG 로 접속하여 SQL문을 작성하세요.  

-- ORACLE EQUI JOIN
SELECT A.EMPLOYEE_ID, A.EMP_NAME, B.JOB_TITLE, C.START_DATE, C.END_DATE, D.DEPARTMENT_NAME  
FROM EMPLOYEES A, JOBS B, JOB_HISTORY C, DEPARTMENTS D 
WHERE A.EMPLOYEE_ID = C.EMPLOYEE_ID 
AND C.DEPARTMENT_ID = D.DEPARTMENT_ID 
AND C.JOB_ID = B.JOB_ID
and A.EMPLOYEE_ID = 101;

SELECT E.EMP_NAME, S.JOB_TITLE, J.START_DATE, J.END_DATE, D.DEPARTMENT_NAME
FROM EMPLOYEES E
INNER JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
INNER JOIN JOB_HISTORY J ON E.EMPLOYEE_ID = J.EMPLOYEE_ID
INNER JOIN JOBS S ON E.JOB_ID = S.JOB_ID
WHERE E.EMPLOYEE_ID = 101;

-- ANSI INNER JOIN
SELECT E.EMPLOYEE_ID, E.EMP_NAME, S.JOB_TITLE, J.START_DATE, J.END_DATE, d.department_name
FROM JOB_HISTORY J
INNER JOIN EMPLOYEES E ON J.EMPLOYEE_ID = E.EMPLOYEE_ID
INNER JOIN DEPARTMENTS D ON J.DEPARTMENT_ID = D.DEPARTMENT_ID
INNER JOIN JOBS S ON J.JOB_ID = S.JOB_ID
WHERE E.EMPLOYEE_ID = 101;

SHOW USER;
SELECT * FROM TAB;

CREATE TABLE EX2_1 (
    C1 CHAR(10),
    C2 VARCHAR2(10),
    C3 VARCHAR2(10),
    C4 NUMBER
);

DESC TABLE EMP01;
CREATE TABLE EMP01 (
    EMPNO NUMBER(4),
    ENAME VARCHAR2(20),
    SAL NUMBER(7,2)
);

SELECT * FROM EMP01;
DESC EMP01;

-- 서브 쿼리로 테이블 생성하기
CREATE TABLE EMP02
AS 
SELECT * FROM EMP; -- 테이블 복사 가능

SELECT * FROM EMP02;
DESC EMP02;

-- 원하는 칼럼으로 구성된 복제 테이블 생성하기
CREATE TABLE EMP03
AS
SELECT EMPNO, ENAME FROM EMP;

SELECT * FROM EMP03;

-- 테이블의 구조만 복사하기
CREATE TABLE EMP04
AS
SELECT * FROM EMP WHERE 1=0; -- 데이터 구조만 가져오기

SELECT * FROM EMP04;
DESC EMP04;
-- 데이터 구조만 출력됨

DESC EMP01;

ALTER TABLE EMP01
ADD(JOB VARCHAR2(9));

ALTER TABLE EMP01
MODIFY(JOB VARCHAR2(30));

ALTER TABLE EMP01
DROP COLUMN JOB;

ALTER TABLE EMP01
SET UNUSED(JOB); 
-- TABLE을 드롭하는데 시간이 걸릴 때 프로그램에 없는 것처럼 UNUSED를 시켜놓고 유지보수 때 삭제
-- DBA가 할 일

DESC EMP01;
SELECT * FROM EMP01;

DROP TABLE OEMP01;
DROP TABLE EMP02 CASCADE CONSTRAINTS;

DROP TABLE DEPT;

CREATE TABLE EMP02
AS
SELECT * FROM EMP;

TRUNCATE TABLE EMP02; -- TRUNCATE = DELETE + COMMIT;
                      -- (DML: INSERT, UPDATE, DELETE) 
DROP TABLE EMP02;

DELETE FROM EMP02;
SELECT * FROM EMP02;
ROLLBACK; 
-- DELETE는 메모리는 지워졌지만 디스크에(TCL(Transaction Control Language)는 유지가 되어있어서 되돌릴 수 있음.

RENAME EMP02 TO TEST;
SELECT * FROM TEST;

-- 데이터 딕셔너리 : 관리 목적으로 쓰는 테이블
-- 유저가 가지고 있는 객체(테이블, 뷰, 인덱스 등)을 스키마라고 함.
-- USER_ 에 사용자에 관련된 정보가 있음.
-- 

SHOW USER;

DESC USER_TABLES;

SELECT TABLE_NAME FROM USER_TABLES ORDER BY TABLE_NAME DESC;

DESC ALL_TABLES;
SELECT OWNER, TABLE_NAME FROM ALL_TABLES;

INSERT DEPT01;

CREATE TABLE DEPT01
AS
SELECT * FROM DEPT WHERE 1 = 2; -- WHERE 1 = 2로 FALSE를 형성해 테이블 구조만 형성

SELECT * FROM DEPT01;

INSERT INTO DEPT01 VALUES (1, 'HONGKILDONG', 'SEOUL');
INSERT INTO DEPT01 VALUES (2, 'LEEJAESEOK', NULL);
INSERT INTO DEPT01 (DEPTNO, DNAME) VALUES (3,'KWANGSOO');
INSERT INTO DEPT01 (DEPTNO) VALUES (4);
INSERT INTO DEPT01 VALUES (5, '', '');

DROP TABLE DEPT01;
CREATE TABLE DEPT01
AS
SELECT * FROM DEPT WHERE 1 = 0;

DESC DEPT;

INSERT INTO DEPT01 (DEPTNO, DNAME, LOC) VALUES (10, 'ACCOUNTING'); -- 앞에 3개 변수 선언, 뒤의 값 2개만 입력 : 오류
INSERT INTO DEPT01 (DEPTNO, DNAME, LOC) VALUES (10, 'ACCOUNTING', 'NEW YORK');

INSERT INTO DEPT01 VALUES (20, 'RESEARCH');
INSERT INTO DEPT01 VALUES (20, 'RESEARCH', 'DALLAS');

INSERT INTO DEPT01 (DEPTNO, DNAME) VALUES (30, 'SALES'); -- 명시적으로 널값이 들어간다.
INSERT INTO DEPT01 VALUES (40, 'OPERATIONS', NULL);
SELECT * FROM DEPT;

DROP TABLE DEPT02;
CREATE TABLE DEPT02
AS
SELECT * FROM DEPT WHERE 1 = 0;

SELECT * FROM DEPT02;

INSERT INTO DEPT02
SELECT * FROM DEPT;

DESC EMP;
SELECT * FROM EMP
WHERE DEPNO = 20;

DROP TABLE EMP_HIR;
CREATE TABLE EMP_HIR
AS
SELECT EMPNO, ENAME, HIREDATE FROM EMP
WHERE 1 = 0;

SELECT * FROM EMP_HIR;

DROP TABLE EMP_MGR;
CREATE TABLE EMP_MGR
AS
SELECT EMPNO, ENAME, MGR FROM EMP
WHERE 1 = 0;

SELECT * FROM EMP_HIR;
SELECT * FROM EMP_MGR; 
-- 하나를 INSERT할 때 두 개의 테이블에 동시에 넣고 싶다면?
INSERT ALL
INTO EMP_HIR VALUES(EMPNO, ENAME, HIREDATE)
INTO EMP_MGR VALUES(EMPNO, ENAME, MGR)
SELECT EMPNO, ENAME, HIREDATE, MGR
FROM EMP
WHERE DEPTNO = 20; 
-- 한 INSERT문으로 EMP 테이블에서 조건(DEPTNO = 20)에 해당하는 변수 EMPNO, ENAME, HIREDATE, MGR
-- 을 EMP_HIR, EMP_MGR테이블로 각각 VALUES로써 삽입한다.

CREATE TABLE EMP_HIR2 (
    NO NUMBER(4),
    NAME VARCHAR2(10),
    HIRE DATE    
);

SELECT * FROM EMP_HIR2;

DESC EMP_HIR2;

INSERT ALL
INTO EMP_HIR2 VALUES(EMPNO, ENAME, HIREDATE)
INTO EMP_MGR VALUES(EMPNO, ENAME, MGR)
SELECT EMPNO, ENAME, HIREDATE, MGR
FROM EMP
WHERE DEPTNO = 20;

DROP TABLE EMP_HIR02;
CREATE TABLE EMP_HIR02 AS SELECT EMPNO, ENAME, HIREDATE FROM EMP WHERE 1=0;
SELECT * FROM EMP_HIR02;  
DROP TABLE EMP_SAL;
CREATE TABLE EMP_SAL AS SELECT EMPNO, ENAME, SAL FROM EMP WHERE 1=0;
SELECT * FROM EMP_SAL;  
INSERT ALL  WHEN HIREDATE > '1982/01/01' THEN INTO EMP_HIR02 VALUES(EMPNO, ENAME, HIREDATE) 
            WHEN SAL > 2000 THEN INTO EMP_SAL VALUES(EMPNO, ENAME, SAL) 
SELECT EMPNO, ENAME, HIREDATE, SAL FROM EMP;  
SELECT * FROM EMP_HIR02;
SELECT * FROM EMP_SAL;

DROP TABLE EMP01;

CREATE TABLE EMP01
AS
SELECT * FROM EMP;

SELECT * FROM EMP01;

UPDATE EMP01
SET DEPTNO=30; -- 죄다 DEPTNO값이 30으로 바뀜
ROLLBACK; -- 다시 원래대로 돌아옴 COMMIT을 해야 디스크에 저장된 값까지 모두 변경됨.
COMMIT;

UPDATE EMP01
SET SAL = SAL*1.1
WHERE JOB = 'MANAGER';
ROLLBACK;

UPDATE EMP01
SET HIREDATE = SYSDATE;

DROP TABLE EMP01;
CREATE TABLE EMP01
AS
SELECT * FROM EMP;

SELECT * FROM EMP01;

UPDATE EMP01
SET DEPTNO = 30, JOB = 'MANAGER' -- SCOTT을 30번 부서로 이동시키고 MANAGER 직위를 부여함
WHERE ENAME = 'SCOTT';

SELECT * FROM DEPT01;

SELECT LOC FROM DEPT01 WHERE DEPTNO = 20;
UPDATE EMP01
SET LOC = (SELECT LOC FROM DEPT01 WHERE DEPTNO = 20);

 